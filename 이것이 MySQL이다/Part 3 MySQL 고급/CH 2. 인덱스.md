# Part 3 MySQL 고급

## CH 2. 인덱스

### 1. 인덱스의 개념

> 인덱스는 책의 뒤에 있는 <찾아보기>와 비슷하다. 어떤 단어를 찾을 때 뒷부분의 <찾아보기>를 참고하여 해당 내용을 찾을 것이다. <찾아보기>가 없다면 책의 처음부터 단어를 찾을 것이다. 만약 운이 좋아 앞부분에서 찾았더라도 뒤에 또 나올 수가 있어 어차피 끝까지 찾아봐야 한다. 지금까지의 예시에서는 데이터의 양이 적기 때문에 인덱스가 없어도 성능에는 별 문제가 되지 않지만, 대용량의 테이블일 경우 성능 차이가 날 수 있다.

- 인덱스는 데이터를 좀 더 빠르게 찾을 수 있도록 해주는 도구
- 필요없는 인덱스를 만들면 데이터베이스가 차지하는 공간만 늘어나고 더 느려질 수도 있음
  - 실제 MySQL이 인덱스를 사용할 지, 전체 테이블을 검색할 지 알아서 판단하나 쓸데없는 인덱스를 만들어서 발생되는 문제점은 많음
- 인덱스 장점
  - 검색 속도가 빨라질 수 있음(항상 그런 것은 아님)
  - 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능 향상
- 인덱스 단점
  - 인덱스가 데이터베이스 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 10% 정도의 추가 공간이 필요
  - 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있음

### 2. 인덱스의 종류와 자동 생성

#### 2-1 인덱스의 종류

- 클러스터형 인덱스(Clustered Index)
  - 사전같은 책
  - 테이블당 한 개만 생성
  - 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬
- 보조 인덱스(Secondary Index)
  - 찾아보기가 있는 책
  - 테이블당 여러 개를 생성

#### 2-2 자동으로 생성되는 인덱스

- 인덱스는 테이블의 열 단위에 생성
- PRIMARY KEY로 지정한 열은 클러스터형 인덱스 생성
- UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스 생성
- UNIQUE 또는 UNIQUE NULL로 지정한 열은 보조 인덱스 생성
- PRIMARY KEY와 UNIQUE NOT NULL이 있으면 PRIMARY KEY로 지정한 열에 우선 클러스터형 인덱스 생성
- PRIMARY KEY로 지정한 열로 데이터가 오름차순 정렬

### 3. 인덱스의 내부 작용

#### 3-1 B-Tree(Balanced Tree, 균형 트리)

- B-Tree는 자료 구조에 나오는 범용적으로 사용되는 데이터의 구조
  - 주로 인덱스를 표현할 때와 그 외에 많이 사용되며, 균형이 잡힌 트리
- 개념적으로 부를 때는 노드라 부르지만, MySQL에서는 노드가 페이지가 되며 인덱스를 구현할 때 기본적으로 B-Tree 구조를 사용
  - 페이지란 16Kbyte 크기의 최소한의 저장 단위

![1](https://user-images.githubusercontent.com/38815618/96454729-3e344600-1257-11eb-860d-750f1ef67fb3.PNG)

<p>
    위의 B-Tree 구조에서 MMM이란 데이터를 찾는다면 우선 루트 페이지를 검색한다. 모든 데이터는 정렬되어 있어 AAA, FFF, LLL을 읽는다. MMM은 LLL 다음에 나오므로 세 번째 리프 페이지로 이동하여 MMM을 찾게 된다. 결국 5건의 데이터를 검색해서 원하는 결과를 찾았으며 두 개의 페이지를 읽었다.
</p>

#### 3-2 페이지 분할

<p>
    인덱스를 구성하면 SELECT의 속도가 급격히 향상된다. 하지만 데이터의 변경 작업(INSERT, UPDATE, DELETE) 시에 성능이 나빠진다. 특히 INSERT 작업이 일어날 때 성능이 급격히 느려진다. 페이지 분할이라는 작업이 발생되기 때문이다.
</p>

![2](https://user-images.githubusercontent.com/38815618/96454732-3eccdc80-1257-11eb-8814-03c46c673a27.PNG)

<p>
    위의 그림은 앞선 그림에서 III 데이터가 삽입된 것이다. 두 번째 리프 페이지에는 한 칸의 빈 공간이 있어서 JJJ가 아래로 한 칸 이동되고 III가 그 자리에 삽입되었다. 여기서 GGG가 입력된다면 다음과 같다.
</p>

![3](https://user-images.githubusercontent.com/38815618/96454733-3eccdc80-1257-11eb-8f50-b5faa0e6e485.PNG)

<p>
    더이상 빈 공간이 없어 페이지 분할 작업이 일어난다. MySQL은 우선 비어있는 페이지를 확보한 후에 두 번째 리프 페이지의 데이터를 공평하게 나누게 된다.
</p>

![4](https://user-images.githubusercontent.com/38815618/96454724-3d031900-1257-11eb-937e-ea9412809bfb.PNG)

<p>
    위의 그림은 앞선 그림에서 PPP와 QQQ 데이터가 삽입된 것이다. PPP를 입력하면 네 번째 리프 페이지에 빈칸이 있어 별 일이 일어나지 않는다. QQQ를 입력하면 네 번째 리프 페이지에 빈칸이 없으므로 페이지 분할 작업이 일어난다. 페이지 분할 후에도 루트 페이지도 빈 칸이 없어 다시 분할하며, 기존의 루트 페이지는 중간 페이지가 된다. 결국 3개의 페이지가 할당되고 2회의 페이지 분할이 발생되었다.
</p>

#### 3-3 클러스터형 인덱스와 보조 인덱스의 구조

- 클러스터형 인덱스 특징
  - 클러스터형 인덱스의 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 업무시간에 클러스터형 인덱스를 생성하는 것은 심각한 시스템 부하를 줄 수 있다.
  - 클러스터형 인덱스는 인덱스 자체의 리프 페이지가 곧 데이터다. 그러므로 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다.
  - 클러스터형 인덱스는 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다.
  - 클러스터형 인덱스는 성능이 좋지만 테이블에 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다.
- 보조 인덱스 특징
  - 보조 인덱스의 생성 시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
  - 보조 인덱스의 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소 값(RID)이다. 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
  - 보조 인덱스는 여러 개 생성할 수 있다. 하지만 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있다.

### 4. 인덱스 생성/변경/삭제

#### 4-1 인덱스 생성

```SQL
CREATE [UNIQUE/FULLTEXT/SPATIAL] INDEX index_name
  [index_type]
  ON tbl_name (index_col_name, ...)
  [index_option]
  [algorithm_option | lock_option]

index_col_name:
  col_name [(length)] [ASC | DESC]

index_type:
  USING {BTREE | HASH}

index_option:
  KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

algorithm_option:
  ALGORITHM [=] {DEFAULT|INPLACE|COPY}

lock_option:
  LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
```

- UNIQUE 옵션은 고유한 인덱스를 만들 것인지 결정
- 디폴트는 UNIQUE가 생략된(중복이 허용되는) 인덱스
- CREATE INDEX로 생성되는 인덱스는 보조 인덱스가 생성
- ASC와 DESC는 정렬 방식
- index_type을 생략하면 B-TREE 형식을 사용

#### 4-2 인덱스 제거

```SQL
DROP INDEX index_name ON tbl_name
  [algorithm_option | lock_option]

algorithm_option:
  ALGORITHM [=] {DEFAULT|INPLACE|COPY}

lock_option:
  LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
```

- 기본 키로 설정된 클러스터형 인덱스의 이름은 항상 PRIMARY로 되어 있으므로 인덱스 이름 부분에 PRIMARY로 써주면 된다. 또한 `ALTER TABLE`문으로 기본 키를 제거해도 클러스터형 인덱스가 제거된다.
- 인덱스를 모두 제거할 때는 되도록 보조 인덱스부터 삭제하도록 한다.
- 인덱스를 많이 생성해 놓은 테이블은 인덱스의 용도를 잘 확인한 후에, 인덱스의 활용도가 떨어진다면 과감히 삭제해 줄 필요가 있다. 그렇지 않으면 전반적인 MySQL의 성능이 저하되는 문제를 야기할 수 있다. 한 달에 한 번 또는 일년에 한 번 사용될 인덱스를 계속 유지할 필요는 없다.

### 5. 결론: 인덱스를 생성해야 하는 경우와 그렇지 않은 경우

- 인덱스는 열 단위에 생성된다.
- WHERE절에서 사용되는 열에 인덱스를 만들어야 한다.
- WHERE절에 사용되더라도 자주 사용해야 가치가 있다.
- 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다.
- 외래 키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다.
- JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
- INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해야 한다.
- 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다.
- 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.
- 사용하지 않는 인덱스는 제거하자
